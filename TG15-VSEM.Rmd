---
title: "Experiments for TG15 with VSEM"
author: "DRC"
date: '`r Sys.Date()`'
output:
  pdf_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
  html_document: default
  word_document: default
---

```{r, include=FALSE}
library(BayesianTools)
```

```{r, include=FALSE}
plotTimeSeriesResults <- function(x, model, observed, error = NULL, plotResiduals = T, start = 1){
  
  if(inherits(x,"bayesianOutput")) parMatrix = getSample(x, start = start)
  else if (class(sampler) == "matrix") parMatrix = sampler
  else stop("wrong type give to variable sampler")
  
  pred <- getPredictiveIntervals(parMatrix = parMatrix, model = model, thin = 1000, quantiles = c(0.025, 0.5, 0.975), error = error)
  
  plotTimeSeries(observed = observed, predicted = pred[2,], confidenceBand = pred[c(1,3),])
}
```

# Setup virtual obs PAR etc

```{r}
set.seed(123)
ndays                 <- 1000
PAR                   <- VSEMcreatePAR(1:ndays)
refPars               <- VSEMgetDefaults()
refPars[12,]          <- c(0.1, 0.001, 0.5)
rownames(refPars)[12] <- "error-sd"
referenceData         <- VSEM(refPars$best[1:11], PAR) 
obs                   <- referenceData + rnorm(length(referenceData), sd = (abs(referenceData) + 1E-7) * refPars$best[12])
```
# Perfect model balanced perfect data 
## Likelihood 
```{r}
newPars <- refPars$best
parSel = c(1:6, 12)
likelihood <- function(x, sum = TRUE){
  x         <- createMixWithDefaults(x, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  diff      <- c(predicted[,1:3] - obs[,1:3])
  llValues  <- dnorm(diff, sd = (abs(c(predicted[,1:3])) + 0.0000001) * x[12], log = T) 
  if (sum == FALSE) return(llValues)
  else return(sum(llValues))
}
```
## Prior
```{r}
prior         <- createUniformPrior(lower = refPars$lower[parSel], upper = refPars$upper[parSel])
```
## Run MCMC
```{r results = "hide", cache=FALSE}
bayesianSetup <- createBayesianSetup(likelihood, prior, best = newPars[parSel], names = rownames(refPars)[parSel])
settings = list(iterations = 100000, adapt = F, optimize = F, proposalScaling = 0.1)
out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", settings = settings)
## settings = list(iterations = 20000)
## out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
```

## Plot results
```{r cache=FALSE, fig.height=7, fig.cap="Output from perfect model after calibration"}
runModel1 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,1])
}
runModel2 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,2])
}
runModel3 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,3])
}

errorFunction <- function(mean, par) rnorm(length(mean), mean = mean, sd = abs(mean)*par[7])
par(mfrow = c(2,2))
plotTimeSeriesResults(x = out, model = runModel1, observed = obs[,1], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel2, observed = obs[,2], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel3, observed = obs[,3], error = errorFunction)
```

# Perfect model unbalanced perfect data 
## Likelihood 
```{r}
newPars <- refPars$best
parSel = c(1:6, 12)
obsSel <- c(1,202,390,550,750,920)
likelihood <- function(x, sum = TRUE){
  x         <- createMixWithDefaults(x, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  diff       <- c(predicted[,c(1,3)] - obs[,c(1,3)])
  llValues1  <- dnorm(diff, sd = (abs(c(predicted[,c(1,3)])) + 0.0000001) * x[12], log = T) 

  diff       <- c(predicted[obsSel,2] - obs[obsSel,2])
  llValues2  <- dnorm(diff, sd = (abs(c(predicted[obsSel,2])) + 0.0000001) * x[12], log = T) 

  if (sum == FALSE) return(llValues)
  else return(sum(llValues1,llValues2))
}
```
## Prior
```{r}
prior         <- createUniformPrior(lower = refPars$lower[parSel], upper = refPars$upper[parSel])
```

## Run MCMC
```{r results= "hide", cache=FALSE}
bayesianSetup <- createBayesianSetup(likelihood, prior, best = newPars[parSel], names = rownames(refPars)[parSel])
settings = list(iterations = 100000, adapt = F, optimize = F, proposalScaling = 0.1)
out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", settings = settings)
## settings = list(iterations = 20000)
## out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
````
## Plot results
```{r cache=FALSE, fig.height=7, fig.cap="Output from perfect model with unbalanced obs after calibration"}
par(mfrow = c(2,2))
plotTimeSeriesResults(x = out, model = runModel1, observed = obs[,1], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel2, observed = obs[,2], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel3, observed = obs[,3], error = errorFunction)
```

# Model with error balanced perfect data (1000 obs) 
Remove the root pool by setting allocation to vegetation Av = 1.0

## Likelihood 
```{r}
newPars <- refPars$best
newPars[8]  <- 1.0
newPars[11] <- 0.0
parSel = c(1:6, 12)
likelihood <- function(x, sum = TRUE){
  x         <- createMixWithDefaults(x, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  diff      <- c(predicted[,1:3] - obs[,1:3])
  llValues  <- dnorm(diff, sd = (abs(c(predicted[,1:3])) + 0.0000001) * x[12], log = T) 
  if (sum == FALSE) return(llValues)
  else return(sum(llValues))
}
```
## Prior
```{r}
prior         <- createUniformPrior(lower = refPars$lower[parSel], upper = refPars$upper[parSel])
```

## Run MCMC
```{r results= "hide", cache=FALSE}
bayesianSetup <- createBayesianSetup(likelihood, prior, best = newPars[parSel], names = rownames(refPars)[parSel])
settings = list(iterations = 100000, adapt = F, optimize = F, proposalScaling = 0.1)
out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", settings = settings)
## settings = list(iterations = 20000)
## out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
```

## Plot results
```{r cache=FALSE, fig.height=7, fig.cap="Output from model with error with 1000 balanced obs after calibration"}
par(mfrow = c(2,2))
plotTimeSeriesResults(x = out, model = runModel1, observed = obs[,1], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel2, observed = obs[,2], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel3, observed = obs[,3], error = errorFunction)
```

# Model with error balanced perfect data (6 obs) 
Remove the root pool by setting allocation to vegetation Av = 1.0

## Likelihood 
```{r}
newPars <- refPars$best
newPars[8]  <- 1.0
newPars[11] <- 0.0
parSel = c(1:6, 12)
obsSel <- c(1,202,390,550,750,920)
likelihood <- function(x, sum = TRUE){
  x         <- createMixWithDefaults(x, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  diff      <- c(predicted[obsSel,1:3] - obs[obsSel,1:3])
  llValues  <- dnorm(diff, sd = (abs(c(predicted[obsSel,1:3])) + 0.0000001) * x[12], log = T) 
  if (sum == FALSE) return(llValues)
  else return(sum(llValues))
}
```
## Prior
```{r}
prior         <- createUniformPrior(lower = refPars$lower[parSel], upper = refPars$upper[parSel])
```

## Run MCMC
```{r results= "hide", cache=FALSE}
bayesianSetup <- createBayesianSetup(likelihood, prior, best = newPars[parSel], names = rownames(refPars)[parSel])
settings = list(iterations = 100000, adapt = F, optimize = F, proposalScaling = 0.1)
out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", settings = settings)
## settings = list(iterations = 20000)
## out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
```

## Plot results
```{r  cache=FALSE, fig.height=7, fig.cap="Output from model with error with six balanced obs after calibration"}
par(mfrow = c(2,2))
plotTimeSeriesResults(x = out, model = runModel1, observed = obs[,1], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel2, observed = obs[,2], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel3, observed = obs[,3], error = errorFunction)
```

# Model with error unbalanced perfect data 
Remove the root pool by setting allocation to vegetation Av = 1.0

## Likelihood 
```{r}
newPars <- refPars$best
newPars[8]  <- 1.0
newPars[11] <- 0.0
parSel = c(1:6, 12)
obsSel <- c(1,202,390,550,750,920)
likelihood <- function(x, sum = TRUE){
  x         <- createMixWithDefaults(x, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  diff       <- c(predicted[,c(1,3)] - obs[,c(1,3)])
  llValues1  <- dnorm(diff, sd = (abs(c(predicted[,c(1,3)])) + 0.0000001) * x[12], log = T) 

  diff       <- c(predicted[obsSel,2] - obs[obsSel,2])
  llValues2  <- dnorm(diff, sd = (abs(c(predicted[obsSel,2])) + 0.0000001) * x[12], log = T) 

  if (sum == FALSE) return(llValues)
  else return(sum(llValues1,llValues2))
}
```
## Prior
```{r}
prior         <- createUniformPrior(lower = refPars$lower[parSel], upper = refPars$upper[parSel])
```

## Run MCMC
```{r results= "hide", cache=FALSE}
bayesianSetup <- createBayesianSetup(likelihood, prior, best = newPars[parSel], names = rownames(refPars)[parSel])
settings = list(iterations = 100000, adapt = F, optimize = F, proposalScaling = 0.1)
out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", settings = settings)
## settings = list(iterations = 20000)
## out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
```
## Plot results
```{r cache=FALSE, fig.height=7, fig.cap="Output from model with error with unbalanced obs after calibration"}
par(mfrow = c(2,2))
plotTimeSeriesResults(x = out, model = runModel1, observed = obs[,1], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel2, observed = obs[,2], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel3, observed = obs[,3], error = errorFunction)
```


# Perfect model balanced data that has additive bias 
```{r}
modobs <- obs
modobs[,2] <- modobs[,2] + 1.0
```
## Likelihood 
```{r}
newPars <- refPars$best
parSel = c(1:6, 12)
likelihood <- function(x, sum = TRUE){
  x         <- createMixWithDefaults(x, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  diff      <- c(predicted[,1:3] - modobs[,1:3])
  llValues  <- dnorm(diff, sd = (abs(c(predicted[,1:3])) + 0.0000001) * x[12], log = T) 
  if (sum == FALSE) return(llValues)
  else return(sum(llValues))
}
```
## Prior
```{r}
prior         <- createUniformPrior(lower = refPars$lower[parSel], upper = refPars$upper[parSel])
```
## Run MCMC
```{r results = "hide", cache=FALSE}
bayesianSetup <- createBayesianSetup(likelihood, prior, best = newPars[parSel], names = rownames(refPars)[parSel])
settings = list(iterations = 100000, adapt = F, optimize = F, proposalScaling = 0.1)
out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", settings = settings)
## settings = list(iterations = 20000)
## out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
```
## Plot results
```{r cache=FALSE, fig.height=7, fig.cap="Output from perfect model and obs with biases after calibration"}
runModel1 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,1])
}
runModel2 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,2])
}
runModel3 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,3])
}

errorFunction <- function(mean, par) rnorm(length(mean), mean = mean, sd = abs(mean)*par[7])
par(mfrow = c(2,2))
plotTimeSeriesResults(x = out, model = runModel1, observed = obs[,1], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel2, observed = obs[,2], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel3, observed = obs[,3], error = errorFunction)
```

# Perfect model balanced data that has additive obs bias with systmatic bias parameter
```{r}
modobs <- obs
modobs[,2] <- modobs[,2] + 1.0
```
## Likelihood 
```{r}
addPars <- refPars
addPars[13,] <- c(2.0, 0.0, 4.0)
newPars <- addPars$best
parSel = c(1:6, 12,13)
## parSel = c(1:6, 12)
likelihood <- function(x, sum = TRUE){
  x         <- createMixWithDefaults(x, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  modobs[,2]<-modobs[,2]+(x[13]-2.0)
  diff      <- c(predicted[,1:3] - modobs[,1:3])
  llValues  <- dnorm(diff, sd = (abs(c(predicted[,1:3])) + 0.0000001) * x[12], log = T) 
  if (sum == FALSE) return(llValues)
  else return(sum(llValues))
}
```
## Prior
```{r}
prior         <- createUniformPrior(lower = addPars$lower[parSel], upper = addPars$upper[parSel])
```
## Run MCMC
```{r results = "hide", cache=FALSE}
bayesianSetup <- createBayesianSetup(likelihood, prior, best = newPars[parSel], names = rownames(addPars)[parSel])
settings = list(iterations = 100000, adapt = F, optimize = F, proposalScaling = 0.1)
out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", settings = settings)
## settings = list(iterations = 20000)
## out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
```
## Plot results
```{r cache=FALSE, fig.height=7, fig.cap="Output from perfect model and obs with biases after calibration"}
runModel1 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,1])
}
runModel2 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,2])
}
runModel3 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,3])
}

errorFunction <- function(mean, par) rnorm(length(mean), mean = mean, sd = abs(mean)*par[7])
par(mfrow = c(2,2))
plotTimeSeriesResults(x = out, model = runModel1, observed = obs[,1], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel2, observed = obs[,2], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel3, observed = obs[,3], error = errorFunction)
```


# Model with error balanced data that has additive obs bias with systmatic bias parameter for obs and model
```{r}
modobs <- obs
modobs[,2] <- modobs[,2] + 1.0
```
## Likelihood 
```{r}
addPars <- refPars
addPars[13,] <- c(2.0, 0.0, 4.0)
addPars[14,] <- c(1.0, 0.1, 5.0)
addPars[15,] <- c(1.0, 0.1, 5.0)
addPars[16,] <- c(1.0, 0.1, 5.0)
row.names(addPars)<-c(row.names(refPars),"obBias","EsysNEE","EsysCv","EsysCs")
newPars <- addPars$best
newPars[8] <- 1.0
newPars[11] <- 0.0
parSel = c(1:6, 12,13,14,15,16)
## parSel = c(1:6, 12)
likelihood <- function(x, sum = TRUE){
  x         <- createMixWithDefaults(x, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  predicted[,1]<-x[14]*predicted[,1]
  predicted[,2]<-x[15]*predicted[,2]
  predicted[,3]<-x[16]*predicted[,3]
  modobs[,2]<-modobs[,2]+(x[13]-2.0)
  diff      <- c(predicted[,1:3] - modobs[,1:3])
  llValues  <- dnorm(diff, sd = (abs(c(predicted[,1:3])) + 0.0000001) * x[12], log = T) 
  if (sum == FALSE) return(llValues)
  else return(sum(llValues))
}
```
## Prior
```{r}
prior         <- createUniformPrior(lower = addPars$lower[parSel], upper = addPars$upper[parSel])
```
## Run MCMC
```{r results = "hide", cache=FALSE}
bayesianSetup <- createBayesianSetup(likelihood, prior, best = newPars[parSel], names = rownames(addPars)[parSel])
settings = list(iterations = 100000, adapt = F, optimize = F, proposalScaling = 0.1)
out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", settings = settings)
## settings = list(iterations = 20000)
## out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)

## Plot results
```{r cache=FALSE, fig.height=7, fig.cap="Output from perfect model and obs with biases after calibration"}
runModel1 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,1])
}
runModel2 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,2])
}
runModel3 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,3])
}

errorFunction <- function(mean, par) rnorm(length(mean), mean = mean, sd = abs(mean)*par[7])
par(mfrow = c(2,2))
plotTimeSeriesResults(x = out, model = runModel1, observed = obs[,1], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel2, observed = obs[,2], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel3, observed = obs[,3], error = errorFunction)
```



# Model with error unbalanced data that has additive obs bias with systmatic bias parameter for obs and model
```{r}
modobs <- obs
modobs[,2] <- modobs[,2] + 1.0
```
## Likelihood 
```{r}
addPars <- refPars
addPars[13,] <- c(2.0, 0.0, 4.0)
addPars[14,] <- c(1.0, 0.5, 2.0)
addPars[15,] <- c(1.0, 0.5, 2.0)
addPars[16,] <- c(1.0, 0.5, 2.0)
row.names(addPars)<-c(row.names(refPars),"obBias","EsysNEE","EsysCv","EsysCs")
newPars <- addPars$best
newPars[8] <- 1.0
newPars[11] <- 0.0
parSel = c(1:6, 12,13,14,15,16)
obsSel <- c(1,202,390,550,750,920)
likelihood <- function(x, sum = TRUE){
  x         <- createMixWithDefaults(x, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  predicted[,1]<-x[14]*predicted[,1]
  predicted[,2]<-x[15]*predicted[,2]
  predicted[,3]<-x[16]*predicted[,3]
  diff       <- c(predicted[,c(1,3)] - modobs[,c(1,3)])
  llValues1  <- dnorm(diff, sd = (abs(c(predicted[,c(1,3)])) + 0.0000001) * x[12], log = T) 
  modobs[,2] <- modobs[,2]+(x[13]-2.0)
  diff       <- c(predicted[obsSel,2] - modobs[obsSel,2])
  llValues2  <- dnorm(diff, sd = (abs(c(predicted[obsSel,2])) + 0.0000001) * x[12], log = T) 
  if (sum == FALSE) return(llValues)
  else return(sum(llValues1,llValues2))
}
```
## Prior
```{r}
prior         <- createUniformPrior(lower = addPars$lower[parSel], upper = addPars$upper[parSel])
```
## Run MCMC
```{r results = "hide", cache=FALSE}
bayesianSetup <- createBayesianSetup(likelihood, prior, best = newPars[parSel], names = rownames(addPars)[parSel])
settings = list(iterations = 100000, adapt = F, optimize = F, proposalScaling = 0.1)
out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", settings = settings)
## settings = list(iterations = 20000)
## out <- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
```

## Plot results
```{r cache=FALSE, fig.height=7, fig.cap="Output from perfect model and obs with biases after calibration"}
runModel1 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,1])
}
runModel2 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,2])
}
runModel3 <- function(par){
  x = createMixWithDefaults(par, newPars, parSel)
  predicted <- VSEM(x[1:11], PAR)
  return(predicted[,3])
}
errorFunction <- function(mean, par) rnorm(length(mean), mean = mean, sd = abs(mean)*par[7])
par(mfrow = c(2,2))
plotTimeSeriesResults(x = out, model = runModel1, observed = obs[,1], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel2, observed = obs[,2], error = errorFunction)
plotTimeSeriesResults(x = out, model = runModel3, observed = obs[,3], error = errorFunction)
```

# TODO Experiment that includes obs bias(es)
Additive and or multiplicative for now 

# TODO Add multiplicative/additive bias terms to model and obs
One parameter for each output to be calibrated

# TODO Add temperature input and Q10 type respiration 
Temperature field has seasonal cycle similar to PAR but should have a slight lag

# TODO include AR type structure in model/obs bias

# Longer term ideas
## use the formalism of Rougier(2007) in BC
The idea here is to learn about the inclusion of errors by analysing model data mismatch after an initial 
calbration. Correlations between the mismatches of NEE, Cv and Cs could hten be included in the calibration 
via Gaussian $\mu$ and $\sigma$ terms using the formalism of Rougier(2007). 

## include GAMMS in BC

## calibrate a simplier model to the output of a more complex model
Before embarking on calibration against real obs an experiment where we create virtual data form a complex data 
and try to fit a simple model using what we have learned already about how to include terms that represent 
model structural error in the BC. 
